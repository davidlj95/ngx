import { execa, execaSync } from 'execa'
import {
  getAppsDir,
  getLibraryDistDir,
  getModuleTemplatesDir,
  getRelativeLibraryDistDir,
  getRelativeLibraryE2EDir,
  getStandaloneTemplatesDir,
  isMain,
  jsonToString,
  Log,
} from './utils.js'
import { basename, join } from 'path'
import { cp, readFile, writeFile } from 'fs/promises'
//ðŸ‘‡ Type assertion needed to make Node.js happy
// https://stackoverflow.com/a/70106896/3263250
import ANGULAR_CLI_VERSIONS_PKG_JSON from '../angular-cli-versions.json' with { type: 'json' }
import ts from 'typescript'
import semverCoerce from 'semver/functions/coerce.js'
import semverGte from 'semver/functions/gte.js'
import { SemVer } from 'semver'

type AngularCliVersion =
  keyof typeof ANGULAR_CLI_VERSIONS_PKG_JSON.devDependencies

interface ExampleApp {
  readonly name: string
  //ðŸ‘‡ Right now name + CLI version MUST match
  //   See example apps workflow cache info step for more info
  readonly cliVersion: AngularCliVersion
  readonly angularCliNewArguments?: ReadonlyArray<string>
  readonly standalone: boolean
  readonly updateDistPathToIncludeBrowserDir: boolean
}

const EXAMPLE_APPS = [
  {
    name: 'v17',
    cliVersion: 'v17',
    angularCliNewArguments: [
      '--standalone=true', // Default in v17, but to be explicit
    ],
    updateDistPathToIncludeBrowserDir: true,
    standalone: true,
  },
  {
    name: 'v16',
    cliVersion: 'v16',
    angularCliNewArguments: [
      '--standalone=false', // Default in v16, but to be explicit
    ],
    updateDistPathToIncludeBrowserDir: false,
    standalone: false,
  },
  {
    name: 'v15',
    cliVersion: 'v15',
    updateDistPathToIncludeBrowserDir: false,
    standalone: false, // No standalone CLI argument in v15
  },
] satisfies ReadonlyArray<ExampleApp>

const EXAMPLE_APPS_BY_NAME = new Map<string, ExampleApp>(
  EXAMPLE_APPS.map((exampleApp) => [exampleApp.name, exampleApp]),
)

// https://angular.dev/cli/new
const DEFAULT_ANGULAR_CLI_NEW_ARGUMENTS = [
  '--inline-style',
  '--minimal',
  '--package-manager=pnpm',
  '--routing',
  '--skip-git',
  '--skip-install',
  '--skip-tests',
  '--style=css',
]
const ANGULAR_CLI_NEW_SSR_ARG = '--ssr'
const ANGULAR_CLI_NEW_SSR_MIN_VERSION = semverCoerceOrExit('v17')

async function createExampleApp({
  exampleApp,
  baseAppDir,
  noCleanup,
  tmpDir,
}: CreateExampleAppOptions) {
  const angularCliVersion = semverCoerceOrExit(exampleApp.cliVersion)
  Log.info(`Creating example app`)

  if (baseAppDir) {
    Log.info('Using "%s" as base app', baseAppDir)
  } else {
    if (!tmpDir) {
      tmpDir = await generateTmpDirAndRegisterCleanupCallback(
        noCleanup ? () => {} : cleanUpTmpDir,
      )
    }
    await createPackageJsonWithAngularCli(exampleApp.cliVersion, tmpDir)
    await installCli(tmpDir)
    baseAppDir = await createAngularApp({
      name: exampleApp.name,
      extraArgs: exampleApp.angularCliNewArguments,
      dir: tmpDir,
      angularCliVersion,
    })
    const cliBinary = '../node_modules/.bin/ng'
    await disableAnalytics({ cliBinary, appDir: baseAppDir })
    await setupSsr({ cliBinary, appDir: baseAppDir, angularCliVersion })
  }

  const appDir = await copyAppDirIntoProject(baseAppDir)
  await Promise.all([
    addLinkedLibrary(appDir),
    copyTemplates({ appDir, standalone: exampleApp.standalone }),
    updateTsConfigToImportJsonFilesAndSetPathMappings(appDir),
    setHoistedNodeLinker(appDir),
  ])
  await installApp(appDir)
  //ðŸ‘‡ Done here as this is something needed for all apps
  //   So if using a base app that wasn't generated by this script, you'll need this too
  await enablePreserveSymlinksCommand({ appDir, appName: exampleApp.name })
}

interface CreateExampleAppOptions {
  readonly exampleApp: ExampleApp
  readonly baseAppDir?: string
  readonly noCleanup?: boolean
  readonly tmpDir?: string
}

function semverCoerceOrExit(version: string): SemVer {
  const semverVersion = semverCoerce(version)
  if (!semverVersion) {
    Log.error(`Version '%s' cannot be coerced into a semver version`, version)
    process.exit(1)
  }
  return semverVersion
}

const DEV_DEPENDENCIES_KEY =
  'devDependencies' satisfies keyof typeof ANGULAR_CLI_VERSIONS_PKG_JSON
const PKG_JSON = 'package.json'

async function generateTmpDirAndRegisterCleanupCallback(
  cleanUpCallback: (tmpDir: string) => void,
): Promise<string> {
  const tmpDir = (await execa('mktemp', ['-d'])).stdout
  registerAbortAndExitCallback(() => cleanUpCallback(tmpDir))
  Log.debug('Temporary dir: "%s"', tmpDir)
  return tmpDir
}

// https://stackoverflow.com/a/14032965/3263250
function registerAbortAndExitCallback(cleanUpCallback: () => void) {
  //ðŸ‘‡ Otherwise this prevents script from exiting
  // process.stdin.resume() // so the program will not close instantly

  process.on('exit', cleanUpCallback)
  // catches ctrl+c event
  process.on('SIGINT', () => {
    Log.info('SIGINT received')
    process.exit(2)
  })
  // catches "kill pid" (for example: nodemon restart)
  process.on('SIGUSR1', () => {
    Log.info('SIGUSR1 received')
    process.exit(2)
  })
  process.on('SIGUSR2', () => {
    Log.info('SIGUSR2 received')
    process.exit(2)
  })
  // catches uncaught exceptions
  process.on('uncaughtException', (error) => {
    Log.error('Uncaught exception')
    console.log(error)
    process.exit(3)
  })
}

// Must be sync as it's an exit handler
// https://stackoverflow.com/a/14032965/3263250
function cleanUpTmpDir(tmpDir: string) {
  Log.step('Cleanup')
  if (tmpDir != '' && tmpDir != '/') {
    Log.step('Deleting temporary dir')
    execaSync('rm', ['-rf', tmpDir])
  }
}

async function createPackageJsonWithAngularCli(
  cliVersion: AngularCliVersion,
  tmpDir: string,
) {
  const pkgJsonFile = join(tmpDir, PKG_JSON)
  const pkgJsonWithOnlyAngularCliDevDep = {
    ...ANGULAR_CLI_VERSIONS_PKG_JSON,
    [DEV_DEPENDENCIES_KEY]: {
      [cliVersion]: ANGULAR_CLI_VERSIONS_PKG_JSON.devDependencies[cliVersion],
    },
  }
  await writeFile(pkgJsonFile, jsonToString(pkgJsonWithOnlyAngularCliDevDep))
}

async function installCli(tmpDir: string) {
  Log.step('Installing Angular CLI')
  const installCommand = execa('pnpm', ['install'], {
    cwd: tmpDir,
    all: true,
    env: { FORCE_COLOR: true.toString() },
  })
  Log.stream(installCommand.all)
  await installCommand
}

async function createAngularApp(opts: {
  name: string
  extraArgs?: ReadonlyArray<string>
  dir: string
  angularCliVersion: SemVer
}): Promise<string> {
  Log.step('Creating Angular app using Angular CLI')
  const addSsrArgument = supportsNgNewWithSsr(opts.angularCliVersion)
  if (addSsrArgument) {
    Log.info('Adding SSR argument')
  }
  const ngNewCommand = execa(
    'pnpm',
    [
      'ng',
      `new`,
      `${opts.name}`,
      ...DEFAULT_ANGULAR_CLI_NEW_ARGUMENTS,
      ...(opts.extraArgs ?? []),
      ...(addSsrArgument ? [ANGULAR_CLI_NEW_SSR_ARG] : []),
    ],
    { cwd: opts.dir, all: true, env: { FORCE_COLOR: true.toString() } },
  )
  Log.stream(ngNewCommand.all)
  await ngNewCommand
  Log.ok('Angular app created')
  return join(opts.dir, opts.name)
}

function supportsNgNewWithSsr(angularCliVersion: SemVer) {
  return semverGte(angularCliVersion, ANGULAR_CLI_NEW_SSR_MIN_VERSION)
}

async function disableAnalytics(opts: { cliBinary: string; appDir: string }) {
  Log.step('Disabling Angular analytics')
  const disableAnalyticsCommand = execa(
    opts.cliBinary,
    ['config', 'cli.analytics', false.toString()],
    {
      cwd: opts.appDir,
      all: true,
      env: { FORCE_COLOR: true.toString() },
    },
  )
  Log.stream(disableAnalyticsCommand.all)
  await disableAnalyticsCommand
}

async function setupSsr(opts: {
  cliBinary: string
  appDir: string
  angularCliVersion: SemVer
}) {
  if (supportsNgNewWithSsr(opts.angularCliVersion)) {
    Log.debug(
      `Skipping SSR setup: Angular CLI %s supports creating apps
      with SSR support, so assuming it has been added already at creation`,
    )
    return
  }
  // Before v17, the recommendation was using @nguniversal for SSR
  // Current docs SSR guide do this with `ng add @angular/ssr`, which starts at v17
  // https://v16.angular.io/guide/universal
  Log.step('Setting up SSR using @nguniversal')
  const ngAddNgUniversalCommand = execa(
    opts.cliBinary,
    ['add', '--skip-confirmation', '@nguniversal/express-engine'],
    {
      cwd: opts.appDir,
      all: true,
      env: { FORCE_COLOR: true.toString() },
    },
  )
  Log.stream(ngAddNgUniversalCommand.all)
  await ngAddNgUniversalCommand
  // Seems there's no way to avoid installing deps
  // https://github.com/angular/angular-cli/blob/16.2.14/packages/angular/cli/src/commands/add/cli.ts#L304
  Log.step('Removing node modules and lockfile')
  const rmNodeModulesAndLockfileCommand = execa(
    'rm',
    ['-rf', 'node_modules', 'pnpm-lock.yaml'],
    {
      cwd: opts.appDir,
      all: true,
      env: { FORCE_COLOR: true.toString() },
    },
  )
  Log.stream(rmNodeModulesAndLockfileCommand.all)
  await rmNodeModulesAndLockfileCommand
}

async function copyAppDirIntoProject(appDir: string) {
  Log.step('Copying app from into project')
  const appDirName = basename(appDir)
  const destination = join(getAppsDir(), appDirName)
  await cp(appDir, destination, { recursive: true })
  return destination
}

/**
 * Due to caching lockfile in CI/CD, cannot use `pnpm add/install`
 * because that would be run twice:
 * - When installing Angular deps (`pnpm i`)
 * - When installing the library (`pnpm add <libDir>`)
 * So the cached lockfile would include library, but then when running
 * `pnpm i` with cached lockfile, `specifiers` section would be out of sync
 * given lockfile contains library, but package.json does not (yet)
 * See https://github.com/davidlj95/ngx/pull/518
 */
async function addLinkedLibrary(appDir: string) {
  Log.step('Adding linked library')
  const appPkgJsonFile = join(appDir, PKG_JSON)
  const [libPkgJson, appPkgJson] = (
    await Promise.all([
      readFile(join(getLibraryDistDir(), PKG_JSON), 'utf8'),
      readFile(join(appDir, PKG_JSON), 'utf8'),
    ])
  ).map(
    (data) =>
      JSON.parse(data) as {
        name: string
        dependencies: Record<string, string>
      },
  )

  appPkgJson.dependencies[libPkgJson.name] =
    `link:${getRelativeLibraryDistDir()}`
  await writeFile(appPkgJsonFile, jsonToString(appPkgJson))
}

async function copyTemplates(opts: { appDir: string; standalone: boolean }) {
  const templatesDir = opts.standalone
    ? getStandaloneTemplatesDir()
    : getModuleTemplatesDir()
  Log.step(
    `Copying ${opts.standalone ? 'standalone' : 'module'} apps template files`,
  )
  Log.item(templatesDir)
  await cp(templatesDir, opts.appDir, { recursive: true })
}

async function updateTsConfigToImportJsonFilesAndSetPathMappings(
  appDir: string,
) {
  Log.step('Adding JSON imports and path mappings to Typescript config')
  const configFileName = ts.findConfigFile(appDir, ts.sys.fileExists)
  if (!configFileName) {
    Log.error('Cannot find Typescript config file')
    process.exit(1)
  }

  const configFile = ts.readConfigFile(configFileName, ts.sys.readFile)
  if (configFile.error) {
    Log.error('Unable to read Typescript config file', configFileName)
    process.exit(1)
  }
  const config = ts.parseJsonConfigFileContent(
    configFile.config,
    ts.sys,
    appDir,
  )
  type TsConfig = { compilerOptions: ts.CompilerOptions }
  const rawConfig = config.raw as TsConfig
  rawConfig.compilerOptions.resolveJsonModule = true
  // ðŸ‘‡ Not needed for Angular v17, given `esModuleInterop` is enabled there
  //    https://www.typescriptlang.org/tsconfig#allowSyntheticDefaultImports
  rawConfig.compilerOptions.allowSyntheticDefaultImports = true
  rawConfig.compilerOptions.paths = {
    ...rawConfig.compilerOptions.paths,
    '@/e2e/*': [join(getRelativeLibraryE2EDir(), '*')],
  }
  await writeFile(configFileName, jsonToString(config.raw))
}

// pnpm specific
// https://stackoverflow.com/a/78268602/3263250
async function setHoistedNodeLinker(appDir: string) {
  Log.step('Configuring pnpm to use hoisted node linker')
  const appNpmRcFile = join(appDir, '.npmrc')
  await writeFile(appNpmRcFile, 'node-linker=hoisted')
}

async function installApp(appDir: string) {
  Log.step('Installing app dependencies')
  const installCommand = execa('pnpm', ['install'], {
    cwd: appDir,
    all: true,
    env: { FORCE_COLOR: true.toString() },
  })
  Log.stream(installCommand.all)
  await installCommand
}

async function enablePreserveSymlinksCommand(opts: {
  appDir: string
  appName: string
}) {
  Log.step('Enabling preserve symlinks')
  const enablePreserveSymlinksCommand = execa(
    'pnpm',
    [
      'ng',
      'config',
      `projects.${opts.appName}.architect.build.options.preserveSymlinks`,
      true.toString(),
    ],
    {
      cwd: opts.appDir,
      all: true,
      env: { FORCE_COLOR: true.toString() },
    },
  )
  Log.stream(enablePreserveSymlinksCommand.all)
  await enablePreserveSymlinksCommand
}

const BASE_APP_DIR_ARG = '--base-app-dir'
const NO_CLEANUP_ARG = '--no-cleanup'
const TMP_DIR_ARG = '--tmp-dir'

if (isMain(import.meta.url)) {
  await createExampleApp(parseArgs(process.argv))
}

function parseArgs(argv: ReadonlyArray<string>): CreateExampleAppOptions {
  let appName: string | null = null
  let baseAppDir: string | undefined
  let noCleanup: boolean = false
  let tmpDir: string | undefined
  for (const arg of argv) {
    if (arg.startsWith('/') || arg.startsWith('node')) {
      continue
    }
    if (arg.startsWith(BASE_APP_DIR_ARG)) {
      const [_, argValue] = arg.split('=')
      baseAppDir = argValue
      continue
    }
    if (arg === NO_CLEANUP_ARG) {
      noCleanup = true
      continue
    }
    if (arg.startsWith(TMP_DIR_ARG)) {
      const [_, argValue] = arg.split('=')
      tmpDir = argValue
      continue
    }
    if (appName === null) {
      appName = arg
      continue
    }
    Log.error('Unknown argument', arg)
    printUsageAndExit()
    process.exit(1)
  }
  if (!appName || appName.length === 0) {
    Log.error('No app name specified. Specify app name as first param')
    printUsageAndExit()
    process.exit(1)
  }
  const exampleApp = EXAMPLE_APPS_BY_NAME.get(appName)
  if (!exampleApp) {
    Log.error('Unknown example app')
    printAppNamesAndExit()
    process.exit(1)
  }
  return {
    exampleApp,
    baseAppDir,
    noCleanup,
    tmpDir,
  }
}

function printUsageAndExit() {
  const scriptName = process.argv[1]
  console.log(`
Usage: node ${scriptName} APP_NAME
       [${BASE_APP_DIR_ARG}=APP_DIR] [${NO_CLEANUP_ARG}]
       [${TMP_DIR_ARG}=TMP_DIR]

       ${BASE_APP_DIR_ARG} allows to use an already created Angular CLI app as base
       If not provided, a fresh new app will be created

       [${NO_CLEANUP_ARG}] will not clean up generated base app dir upon process exit
       Useful to use the same base app dir later. If using ${TMP_DIR_ARG}, no cleanup
       will happen anyway.

       [${TMP_DIR_ARG}=TMP_DIR] lets you set the temporary dir where Angular CLI will
       be installed and a new Angular app will be created. A "package.json" will be
       created there to install the CLI and allow caching lockfile + deps in CI/CD.
       Does nothing if ${BASE_APP_DIR_ARG} is used. Directory will not be cleaned up
       as wasn't created by the script (therefore implicitly enabling ${NO_CLEANUP_ARG})
  `)
  printAppNamesAndExit()
}

function printAppNamesAndExit() {
  Log.info('Known app names:')
  ;[...EXAMPLE_APPS_BY_NAME.keys()].forEach((name) => Log.item(name))
  process.exit(1)
}
